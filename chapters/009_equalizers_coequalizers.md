# Chapter 9: Equalizers and Coequalizers

So far, we have considered limits and colimits over diagrams whose underlying category is in `FinSet`, that is,
diagrams with no non-trivial morphisms. Let us now explore the behavior of limits and colimits for other diagrams.
The additional property of limits and colimits that has been so far unused is that they induce commutativity, that is,
any morphisms from the cone of the limit to the same object must be equal.

For a diagram `Di :: [D, C]`, the simplest `D :: Cat` for which commutativity is not trivial is when `D` is composed
of two objects and two parallel morphisms, that is, two morphisms with the same origin and destination. Let us call
`P :: Cat`, the walking parallel morphism, the category with two objects and two non-trivial morphisms that are
parallel. A limit over this diagram is known as an equalizer, and a colimit is known as a coequalizer.

## Equalizers

The limit in `C :: Cat` over diagram `Di :: [P, C]`, if it exists, selects two parallel morphisms in `C`,
`f, g :: C ^ I`, `f, g :: x -> y`, and yields a new object `eq(f, g) :: Cat`. In the maximalist case, if the
commutativity condition would impose no restrictions, this would be the product `x * y`. However, the commutativity
condition says that for any other `c :: C`, and its induced morphisms `i : c -> x`, `j : c -> y`, we have that
`i . f = j` and `i . g = j`. In other words, `i . f = i . g`. Since `j` is determined by `i`, we can drop it.

The equalizer `eq(f, g) :: Cat` then has the property that any morphism `i : c -> x` with the property that
`i . f = i . g` is equivalent to a morphism `h : c -> eq(f, g)`. Then consider two morphisms `h, h' : c -> eq(f, g)`
and a morphism `e : eq(f, g) -> x` so that `h . e = h' . e : c -> x`. Then we have that `h . e . f = h' . e . g`,
so if we denote `m = h . e = h' . e`, we have `m . f = m . g`. Since both map to the same morphism, we have
`h = h'`.

This means that any morphism `e : eq(f, g) -> x` has the property that `h . e = h' . e` implies `h = h'`. A morphism
with this property is known as a monomorphism, and can be described as monic. In `Set`, a monomorphism is an injective
function. Each `h : c -> eq(f, g)` is in bijection with `h . e : c -> x`, but we already have that `h` is in
bijection with `i : c -> x`. Then we can define `e` so that `h . e = i`. This implies for any `h`, we have
`h . e . f = h . e . g`. Thus, `e . f = e . g`, and any other `i` so that `i . f = i . g` has a unique `h` so that
`h . e = i`.

Then, for `f, g: x -> y`, the definition of an equalizer `eq(f, g)` is an object `equ :: C` and a morphism
`e : equ -> x` so that `e . f = e . g`, and any other object `equ' :: C` with the same property is derivable from `equ`
by precomposition. The second condition, that all other objects must be derivable from an object in a unique way, is
known as a universal property, and all limits and colimits have such a condition.

## Equalizers in Sets

To ground this definition, let us consider if `f, g :: Set ^ I`. Then the equalizer `eq(f, g)` is composed of a set
`equ` and a function `e : equ -> X` with the property that `f(e(equ)) = g(e(equ))`, and the set is universal, that is,
it's the most comprehensive set possible with this property. As `e` is injective, it maps each element of `equ` to a
unique value `x`, so we have that `f(x) = g(x)`, and each value of `equ` corresponds to such a solution. In other
words, `equ` is the set of values `x :: X` so that `f(x) = g(x)`.

## Coequalizers

Then, for `f, g : x -> y`, `coeq(f, g)` is the object so that any morphism `i : y -> c` with the condition that
`f . i = g . i` is equivalent to a morphism `h : coeq(f, g) -> c`. If we have two morphisms `h, h' : coeq(f, g) -> c`
and `e : y -> coeq(f, g)` so that `e . h = e . h'`, then `h = h'`. This is called an epimorphism, and the adjective
form is epic. In `Set`, it is equivalent to a surjective function. We define `e` so that `e . h = i`. Then,
`f . e . h = g . e . h'`, so `f . e = g . e`.

In other words, `coeq(f, g)` is an object `coe :: C` and a morphism `e : y -> coe` so that `f . e = g . e` and `coe` is
the object with the universal property.

Let us consider coequalizers in `Set`. We have a set `coe` and a surjective function `e : Y -> coe`, so that
`e(f(x)) = e(g(x))`. In other words, `e` makes it so that, if `f(x) =/= g(x)`, their image over `e` is equal instead,
and `coe` is the largest possible set with this property that still has `e` as surjective. In other words, `coe` is
the quotient set of `Y` generated by the relation `f(x) ~ g(x)`.

## Pullbacks and Pushouts

The walking cospan is the category with three objects, `a, b, c :: C` and two non-trivial morphisms, namely
`f : a -> b` and `g : c -> b`. A cospan is a diagram that starts in a walking cospan. The limit over a cospan is known
as a pullback, and the colimit is known as a pushout.

A pullback, then, has the commutativity condition as `i . f = i . g`. While the definition is the same regardless,
they are easier to reason about if we assume that we have the product `d = a * c`. In that case, we can define
`f', g' : d -> b` as `f' = first . f`, `g' = second . f`, and this construction is equivalent due to the properties of
products. This makes a pullback into an instance of an equalizer.

As such, a pullback is an object `Pb :: C` and two morphisms `x : Pb -> a`, `y : Pb -> c` with the property that
`x . f = y . g` and `Pb` fulfills the universal property. In `Set`, `Pb :: X * Y` is the set of values so
that `x :: X`, `y :: Y`, `f(x) = g(y)`. This is equivalent to an equation in two values.

Similarly, if coproducts exist, pushouts are instances of coequalizers. As such, a pushout is an object `Po :: C` and
two morphisms `x : a -> Po`, `y : c -> Po` so that `f . x = g . y` and `Po` is the universal property. In `Set`, 
`Po :: X + Y` is the quotient set generated by the relation `x ~ y` where `x = f(a) :: X` and `y = g(a) :: Y` for any
`a :: X + Y`.

## Complete and Cocomplete categories

A category is complete if it has all limits, and cocomplete if it has all colimits. If it has all limits and colimits,
it is referred to as bicomplete. In fact, for a category to be complete, it is sufficient that it has all products and
equalizers, or alternatively, all pullbacks and a terminal object. Similarly, a category is cocomplete if it has all
coproducts and coequalizers, or alternatively, all pushouts and an initial object.
